{
  "id": "langchain_pipe",
  "name": "LangChain Pipe",
  "meta": {
    "description": "Example Pipe Function to utilize LangChain ",
    "type": "pipe",
    "manifest": {
      "title": "LangChain Pipe Function",
      "author": "Colby Sawyer @ Attollo LLC (mailto:colby.sawyer@attollodefense.com)",
      "author_url": "https://github.com/ColbySawyer7",
      "version": "0.1.0"
    }
  },
  "content": "\"\"\"\ntitle: LangChain Pipe Function\nauthor: Colby Sawyer @ Attollo LLC (mailto:colby.sawyer@attollodefense.com)\nauthor_url: https://github.com/ColbySawyer7\nversion: 0.1.0\n\nThis module defines a Pipe class that utilizes LangChain\n\"\"\"\nimport time\nfrom typing import Optional, Callable, Awaitable\n\nfrom open_webui.models.users import Users\nfrom open_webui.utils.chat import generate_chat_completion\nfrom pydantic import BaseModel, Field\n\n\nclass Pipe:\n    class Valves(BaseModel):\n        emit_interval: float = Field(\n            default=2.0, description=\"Interval in seconds between status emissions\"\n        )\n        enable_status_indicator: bool = Field(\n            default=True, description=\"Enable or disable status indicator emissions\"\n        )\n\n    def __init__(self):\n        self.type = \"pipe\"\n        self.id = \"langchain_pipe\"\n        self.name = \"LangChain Pipe\"\n        self.valves = self.Valves()\n        self.last_emit_time = 0\n        pass\n\n    async def emit_status(\n            self,\n            __event_emitter__: Callable[[dict], Awaitable[None]],\n            level: str,\n            message: str,\n            done: bool,\n    ):\n        current_time = time.time()\n        if (\n                __event_emitter__\n                and self.valves.enable_status_indicator\n                and (\n                current_time - self.last_emit_time >= self.valves.emit_interval or done\n        )\n        ):\n            await __event_emitter__(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": \"complete\" if done else \"in_progress\",\n                        \"level\": level,\n                        \"description\": message,\n                        \"done\": done,\n                    },\n                }\n            )\n            self.last_emit_time = current_time\n\n    async def pipe(\n            self, body: dict,\n            __request__: Optional[dict] = None,\n            __user__: Optional[dict] = None,\n            __event_emitter__: Callable[[dict], Awaitable[None]] = None,\n            __event_call__: Callable[[dict], Awaitable[dict]] = None,\n    ) -> Optional[dict]:\n        await self.emit_status(\n            __event_emitter__, \"info\", \"/initiating Chain\", False\n        )\n        messages = body.get(\"messages\", [])\n        # Use the unified endpoint with the updated signature\n        user = Users.get_user_by_id(__user__[\"id\"])\n        await self.emit_status(\n            __event_emitter__, \"info\", \"Starting Chain\", False\n        )\n        messages = body.get(\"messages\", [])\n        # Verify a message is available\n        if messages:\n            question = messages[-1][\"content\"]\n        # If no message is available alert user\n        else:\n            await self.emit_status(__event_emitter__, \"error\", \"No messages found in the request body\", True)\n            body[\"messages\"].append({\"role\": \"assistant\", \"content\": \"No messages found in the request body\"})\n\n        await self.emit_status(__event_emitter__, \"info\", \"Complete\", True)\n\n        return await generate_chat_completion(__request__, body, user)\n"
}